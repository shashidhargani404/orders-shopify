{"ast":null,"code":"/** Franklin M. Liang's hyphenation algorithm, implemented in Javascript.\n *  Copyright (C) 2016 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the MIT license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var // settings\n  SETTING_DEBUG = false,\n      SETTING_HYPHEN_CHAR = \"\\u00AD\";\n\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var pattern,\n        patternData,\n        patternIndex = 0;\n    var p = [];\n    var levels = new Array(text.length + 1);\n\n    for (var i = levels.length; i--;) levels[i] = 0;\n\n    while (patternData = patterns[patternIndex++]) {\n      var patternEntityIndex = text.toLocaleLowerCase().indexOf(patternData.text);\n      var patternFits = patternEntityIndex > -1 && (patternData.stickToLeft ? patternEntityIndex === 0 : true) && (patternData.stickToRight ? patternEntityIndex + patternData.text.length === text.length : true);\n\n      if (patternFits) {\n        p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n        for (var i = 0; i < patternData.levels.length; i++) levels[patternEntityIndex + i] = Math.max(patternData.levels[i], levels[patternEntityIndex + i]);\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var hyphenatedText = \"\",\n        leveledText = \"\",\n        debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug) console.log.apply(console, [text, \"->\"].concat(p).concat([\"->\"]).concat(levels).concat([\"->\", leveledText]).concat([\"->\", debugHyphenatedText]));\n    return hyphenatedText;\n  }\n\n  function iterateSourceText(text) {\n    var nextCharIndex = 0;\n    var states = {\n      readWord: 1,\n      returnWord: 2,\n      returnChar: 3\n    };\n    return {\n      next: function () {\n        var nextChar,\n            nextWord = \"\";\n\n        while (nextChar = text.charAt(nextCharIndex++)) {\n          var charIsSpaceOrSpecial = /\\s|[\\!-\\@\\[-\\`\\{-\\xbf]/.test(nextChar);\n          var state = !charIsSpaceOrSpecial ? states.readWord : state === states.readWord ? states.returnWord : states.returnChar;\n\n          switch (state) {\n            case states.readWord:\n              nextWord += nextChar;\n              break;\n\n            case states.returnWord:\n              nextCharIndex--;\n              return nextWord;\n\n            case states.returnChar:\n              return nextChar;\n          }\n        }\n\n        if (nextWord !== \"\") {\n          return nextWord;\n        }\n      }\n    };\n  }\n\n  function start(text, patterns, cache, debug, hyphenChar) {\n    var newText = \"\",\n        nextWord,\n        readWord = iterateSourceText(text),\n        states = {\n      hyphenateWord: 1,\n      concatenate: 2\n    },\n        processedN = 0,\n        hyphenatedN = 0;\n\n    while (nextWord = readWord.next()) {\n      var state = nextWord.length > 4 ? states.hyphenateWord : states.concatenate;\n\n      switch (state) {\n        case states.hyphenateWord:\n          if (!cache[nextWord]) cache[nextWord] = hyphenateWord(nextWord, patterns, debug, hyphenChar);\n          if (nextWord !== cache[nextWord]) hyphenatedN++;\n          nextWord = cache[nextWord];\n\n        case states.concatenate:\n          newText += nextWord;\n      }\n\n      processedN++;\n    }\n\n    if (debug) console.log(\"----------------\\nHyphenation stats: \" + processedN + \" words processed, \" + hyphenatedN + \" words hyphenated\");\n    return newText;\n  } // extract useful data from pattern\n\n\n  function preprocessPattern(pattern) {\n    var patternCharIndex = 0,\n        patternChar,\n        patternData = {\n      pattern: pattern,\n      text: \"\",\n      levels: [],\n      stickToLeft: 0,\n      stickToRight: 0\n    },\n        states = {\n      alphabet: 1,\n      level: 2,\n      stickToLeft: 3,\n      stickToRight: 4\n    };\n\n    while (patternChar = pattern.charAt(patternCharIndex++)) {\n      var charIsDot = patternChar === \".\",\n          charIsNumber = !charIsDot && /\\d/.test(patternChar),\n          state = charIsDot ? patternCharIndex - 1 === 0 ? states.stickToLeft : states.stickToRight : charIsNumber ? states.level : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n\n  function purifyPatterns(text) {\n    return text // Remove comments\n    .replace(/%.*/g, \"\") // Remove repeating spaces\n    .replace(/\\s+/g, \" \") // Trim spaces\n    .replace(/^\\s|\\s$/g, \"\") // Split to Array\n    .split(\" \");\n  } // Hyphenator factory\n\n\n  return function (patternsDefinition, settings) {\n    var // Settings\n    debug = settings && settings.debug !== undefined && settings.debug || SETTING_DEBUG,\n        hyphenChar = settings && settings.hyphenChar !== undefined && settings.hyphenChar || SETTING_HYPHEN_CHAR,\n        cache = {},\n        // Preprocess patterns\n    patterns = (patternsDefinition.patterns.splice ? patternsDefinition.patterns : purifyPatterns(patternsDefinition.patterns)).map(function (pattern) {\n      return preprocessPattern(pattern);\n    }); // Prepare cache\n\n    (patternsDefinition.exceptions.splice ? patternsDefinition.exceptions : purifyPatterns(patternsDefinition.exceptions)).forEach(function (exception) {\n      cache[exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n    }); // Hyphenator function\n\n    return function (text) {\n      return start(text, patterns, cache, debug, hyphenChar);\n    };\n  };\n});","map":{"version":3,"sources":["/home/shash/web-dev/playground/heroku/shopify/client/node_modules/hyphen/hyphen.js"],"names":["root","factory","define","amd","module","exports","createHyphenator","SETTING_DEBUG","SETTING_HYPHEN_CHAR","hyphenateWord","text","patterns","debug","hyphenChar","pattern","patternData","patternIndex","p","levels","Array","length","i","patternEntityIndex","toLocaleLowerCase","indexOf","patternFits","stickToLeft","stickToRight","push","join","Math","max","hyphenatedText","leveledText","debugHyphenatedText","charAt","console","log","apply","concat","iterateSourceText","nextCharIndex","states","readWord","returnWord","returnChar","next","nextChar","nextWord","charIsSpaceOrSpecial","test","state","start","cache","newText","concatenate","processedN","hyphenatedN","preprocessPattern","patternCharIndex","patternChar","alphabet","level","charIsDot","charIsNumber","prevCharIsNumber","parseInt","purifyPatterns","replace","split","patternsDefinition","settings","undefined","splice","map","exceptions","forEach","exception"],"mappings":"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","sourcesContent":["/** Franklin M. Liang's hyphenation algorithm, implemented in Javascript.\n *  Copyright (C) 2016 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the MIT license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function() {\n  var // settings\n    SETTING_DEBUG = false,\n    SETTING_HYPHEN_CHAR = \"\\u00AD\";\n\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var pattern,\n      patternData,\n      patternIndex = 0;\n\n    var p = [];\n\n    var levels = new Array(text.length + 1);\n\n    for (var i = levels.length; i--; ) levels[i] = 0;\n\n    while ((patternData = patterns[patternIndex++])) {\n      var patternEntityIndex = text\n        .toLocaleLowerCase()\n        .indexOf(patternData.text);\n\n      var patternFits =\n        patternEntityIndex > -1 &&\n        (patternData.stickToLeft ? patternEntityIndex === 0 : true) &&\n        (patternData.stickToRight\n          ? patternEntityIndex + patternData.text.length === text.length\n          : true);\n\n      if (patternFits) {\n        p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n        for (var i = 0; i < patternData.levels.length; i++)\n          levels[patternEntityIndex + i] = Math.max(\n            patternData.levels[i],\n            levels[patternEntityIndex + i]\n          );\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[\n      levels.length - 2\n    ] = 0;\n\n    var hyphenatedText = \"\",\n      leveledText = \"\",\n      debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText +=\n        (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug)\n      console.log.apply(\n        console,\n        [text, \"->\"]\n          .concat(p)\n          .concat([\"->\"])\n          .concat(levels)\n          .concat([\"->\", leveledText])\n          .concat([\"->\", debugHyphenatedText])\n      );\n\n    return hyphenatedText;\n  }\n\n  function iterateSourceText(text) {\n    var nextCharIndex = 0;\n\n    var states = { readWord: 1, returnWord: 2, returnChar: 3 };\n\n    return {\n      next: function() {\n        var nextChar,\n          nextWord = \"\";\n\n        while ((nextChar = text.charAt(nextCharIndex++))) {\n          var charIsSpaceOrSpecial = /\\s|[\\!-\\@\\[-\\`\\{-\\xbf]/.test(nextChar);\n\n          var state = !charIsSpaceOrSpecial\n            ? states.readWord\n            : state === states.readWord\n              ? states.returnWord\n              : states.returnChar;\n\n          switch (state) {\n            case states.readWord:\n              nextWord += nextChar;\n              break;\n\n            case states.returnWord:\n              nextCharIndex--;\n              return nextWord;\n\n            case states.returnChar:\n              return nextChar;\n          }\n        }\n        if (nextWord !== \"\") {\n          return nextWord;\n        }\n      }\n    };\n  }\n\n  function start(text, patterns, cache, debug, hyphenChar) {\n    var newText = \"\",\n      nextWord,\n      readWord = iterateSourceText(text),\n      states = { hyphenateWord: 1, concatenate: 2 },\n      processedN = 0,\n      hyphenatedN = 0;\n\n    while ((nextWord = readWord.next())) {\n      var state =\n        nextWord.length > 4 ? states.hyphenateWord : states.concatenate;\n\n      switch (state) {\n        case states.hyphenateWord:\n          if (!cache[nextWord])\n            cache[nextWord] = hyphenateWord(\n              nextWord,\n              patterns,\n              debug,\n              hyphenChar\n            );\n\n          if (nextWord !== cache[nextWord]) hyphenatedN++;\n\n          nextWord = cache[nextWord];\n\n        case states.concatenate:\n          newText += nextWord;\n      }\n\n      processedN++;\n    }\n\n    if (debug)\n      console.log(\n        \"----------------\\nHyphenation stats: \" +\n          processedN +\n          \" words processed, \" +\n          hyphenatedN +\n          \" words hyphenated\"\n      );\n\n    return newText;\n  }\n\n  // extract useful data from pattern\n  function preprocessPattern(pattern) {\n    var patternCharIndex = 0,\n      patternChar,\n      patternData = {\n        pattern: pattern,\n        text: \"\",\n        levels: [],\n        stickToLeft: 0,\n        stickToRight: 0\n      },\n      states = { alphabet: 1, level: 2, stickToLeft: 3, stickToRight: 4 };\n\n    while ((patternChar = pattern.charAt(patternCharIndex++))) {\n      var charIsDot = patternChar === \".\",\n        charIsNumber = !charIsDot && /\\d/.test(patternChar),\n        state = charIsDot\n          ? patternCharIndex - 1 === 0\n            ? states.stickToLeft\n            : states.stickToRight\n          : charIsNumber\n            ? states.level\n            : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n\n  function purifyPatterns(text) {\n    return (\n      text\n        // Remove comments\n        .replace(/%.*/g, \"\")\n        // Remove repeating spaces\n        .replace(/\\s+/g, \" \")\n        // Trim spaces\n        .replace(/^\\s|\\s$/g, \"\")\n        // Split to Array\n        .split(\" \")\n    );\n  }\n\n  // Hyphenator factory\n  return function(patternsDefinition, settings) {\n    var // Settings\n      debug =\n        (settings && settings.debug !== undefined && settings.debug) ||\n        SETTING_DEBUG,\n      hyphenChar =\n        (settings &&\n          settings.hyphenChar !== undefined &&\n          settings.hyphenChar) ||\n        SETTING_HYPHEN_CHAR,\n      cache = {},\n      // Preprocess patterns\n      patterns = (patternsDefinition.patterns.splice\n        ? patternsDefinition.patterns\n        : purifyPatterns(patternsDefinition.patterns)\n      ).map(function(pattern) {\n        return preprocessPattern(pattern);\n      });\n    // Prepare cache\n    (patternsDefinition.exceptions.splice\n      ? patternsDefinition.exceptions\n      : purifyPatterns(patternsDefinition.exceptions)\n    ).forEach(function(exception) {\n      cache[exception.replace(/\\-/g, \"\")] = exception.replace(\n        /\\-/g,\n        hyphenChar\n      );\n    });\n\n    // Hyphenator function\n    return function(text) {\n      return start(text, patterns, cache, debug, hyphenChar);\n    };\n  };\n});\n"]},"metadata":{},"sourceType":"script"}